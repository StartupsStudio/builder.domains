---
title: "The Technical Architecture of Instant Domain Provisioning"
description: "Deep dive into how builder.domains achieves sub-second domain provisioning with global SSL and zero-config DNS."
date: "2026-05-21"
author: "Builder Domains Team"
tags: ["architecture", "technical", "infrastructure"]
---

# The Technical Architecture of Instant Domain Provisioning

How do you go from "claim domain" to "live with SSL globally" in under 5 seconds? Here's the technical architecture that makes instant provisioning possible.

## The Traditional Architecture (Why It's Slow)

```
Traditional Domain Registration Flow:

1. User submits registration → 30 seconds
2. Payment processing → 10 seconds
3. Queue registration job → 5 seconds
4. Contact registry → 60 seconds
5. Registry processes → 120 seconds
6. Confirmation email → 30 seconds
7. User clicks email → (minutes to hours)
8. Nameserver update → 60 seconds
9. DNS propagation → 24-48 hours
10. SSL certificate request → 120 seconds
11. Certificate validation → 300 seconds
12. Certificate deployment → 60 seconds

Total: 25-50 hours
```

## The builder.domains Architecture (< 5 seconds)

```
Instant Provisioning Flow:

1. API request received → Edge Network (< 10ms)
2. Validate + Reserve domain → Distributed DB (< 100ms)
3. Generate configuration → In-memory (< 50ms)
4. Deploy to edge → Global network (< 500ms)
5. SSL certificate → Pre-provisioned (< 100ms)
6. DNS activation → Edge DNS (< 100ms)
7. Health check → Automated (< 200ms)
8. Response to user → (< 1000ms total)

Total: < 1 second (3000× faster)
```

## Component Architecture

### 1. Edge Network Layer

```typescript
// Request hits edge network first
class EdgeNetwork {
  // 275+ global locations
  locations = [
    'us-east-1', 'us-west-1', 'eu-west-1', 'eu-central-1',
    'ap-southeast-1', 'ap-northeast-1', /* ... 269 more */
  ];

  async handleRequest(request: DomainRequest) {
    // Route to nearest edge location
    const edge = this.nearestEdge(request.clientIP);

    // Process at edge (< 50ms latency globally)
    return await edge.process(request);
  }

  nearestEdge(clientIP: string) {
    // Geographic routing
    const location = geoIP(clientIP);
    return this.locations.closest(location);
  }
}
```

### 2. Distributed Database

```typescript
// Globally distributed, eventually consistent
class DomainDatabase {
  // CockroachDB or similar distributed SQL
  private db: DistributedDB;

  async claimDomain(subdomain: string) {
    // Atomic check-and-reserve
    const result = await this.db.query(`
      INSERT INTO domains (subdomain, status, created_at)
      VALUES ($1, 'claimed', NOW())
      ON CONFLICT (subdomain) DO NOTHING
      RETURNING *
    `, [subdomain]);

    if (result.rows.length === 0) {
      throw new DomainTakenError();
    }

    // Domain reserved across all regions in < 100ms
    return result.rows[0];
  }

  // Multi-region replication
  replicationFactor = 5;  // Data in 5 regions
  consistency = 'eventual';  // Fast writes
  readLatency = '< 10ms';   // Read from nearest replica
  writeLatency = '< 100ms'; // Global consensus
}
```

### 3. SSL Certificate Management

```typescript
class SSLCertificateManager {
  // Pre-provision wildcard certificates
  async provisionWildcardCert() {
    // Request wildcard cert for *.build
    const cert = await letsEncrypt.request({
      domains: ['*.build', '*.*.build'], // 2-level wildcard
      validationMethod: 'dns-01',
      autoRenew: true
    });

    // Deploy to all edge locations
    await this.deployGlobally(cert);

    return cert;
  }

  // Certificate cache at edge
  certCache = new Map(); // In-memory at each edge

  async getCertificate(domain: string) {
    // Check cache first (< 1ms)
    if (this.certCache.has(domain)) {
      return this.certCache.get(domain);
    }

    // Fallback: Fetch from central store (< 50ms)
    const cert = await this.fetchCertificate(domain);
    this.certCache.set(domain, cert);

    return cert;
  }

  // Automatic renewal
  async autoRenew() {
    setInterval(async () => {
      const expiringCerts = await this.findExpiringCerts({
        daysUntilExpiry: 30
      });

      for (const cert of expiringCerts) {
        await this.renewCertificate(cert);
      }
    }, 86400000); // Daily check
  }
}
```

### 4. DNS Management

```typescript
class EdgeDNS {
  // DNS records in distributed key-value store
  private store: DistributedKV; // Redis, DynamoDB, etc.

  async setDNSRecord(domain: string, record: DNSRecord) {
    // Write to distributed store
    await this.store.set(`dns:${domain}`, record, {
      replicate: 'global',  // Replicate to all regions
      ttl: record.ttl || 300
    });

    // Propagate to all edge locations (< 5 seconds)
    await this.propagateToEdge(domain, record);
  }

  async resolve(domain: string): Promise<DNSRecord> {
    // Resolve from edge (< 10ms)
    const record = await this.store.get(`dns:${domain}`);

    if (!record) {
      return this.default404Response;
    }

    return record;
  }

  // No traditional DNS propagation needed
  // Changes live in < 5 seconds globally
}
```

### 5. Configuration Engine

```typescript
class DomainConfigEngine {
  async generateConfig(domain: Domain) {
    // Generate complete configuration
    const config = {
      dns: this.generateDNSConfig(domain),
      ssl: this.generateSSLConfig(domain),
      routing: this.generateRoutingConfig(domain),
      security: this.generateSecurityConfig(domain),
      monitoring: this.generateMonitoringConfig(domain)
    };

    // Compile to edge-executable format
    const compiled = await this.compile(config);

    // Deploy to edge network
    await this.deployToEdge(domain, compiled);

    return config;
  }

  compile(config: DomainConfig) {
    // Convert to edge runtime format (Cloudflare Workers, etc.)
    return {
      router: this.generateRouterFunction(config),
      middleware: this.generateMiddleware(config),
      handlers: this.generateHandlers(config)
    };
  }
}
```

## The Request Flow

### Step 1: API Request

```bash
POST /domains/claim
{
  "subdomain": "my-app",
  "tld": ".build"
}
```

### Step 2: Edge Processing

```typescript
// Request hits edge network
async function handleClaimRequest(req: Request) {
  const { subdomain, tld } = await req.json();

  // Validate (< 10ms)
  if (!isValid(subdomain)) {
    return error(400, 'Invalid subdomain');
  }

  // Check availability + reserve (< 100ms)
  try {
    const domain = await db.claimDomain(subdomain, tld);
  } catch (DomainTakenError) {
    return error(409, 'Domain taken');
  }

  // Generate configuration (< 50ms)
  const config = await configEngine.generate(domain);

  // Deploy to edge (< 500ms)
  await edgeDeployment.deploy(domain, config);

  // Verify deployment (< 200ms)
  await healthCheck(domain);

  // Return success (total: < 1000ms)
  return success({
    domain: domain.fqdn,
    status: 'live',
    ssl: 'active',
    url: `https://${domain.fqdn}`
  });
}
```

### Step 3: Global Propagation

```typescript
// Deploy configuration globally
class GlobalDeployment {
  async deploy(domain: Domain, config: Config) {
    // Deploy to all edge locations in parallel
    const deployments = this.edgeLocations.map(location =>
      location.deploy({
        domain: domain.fqdn,
        config,
        priority: 'high'
      })
    );

    // Wait for majority (not all) to succeed
    // Quorum-based deployment
    const results = await Promise.all(deployments);
    const successRate = results.filter(r => r.success).length / results.length;

    if (successRate < 0.9) {
      throw new DeploymentError('Failed to reach quorum');
    }

    // Remaining edges catch up via gossip protocol
    return {
      deployed: true,
      coverage: `${(successRate * 100).toFixed(1)}%`,
      latency: Math.max(...results.map(r => r.latency))
    };
  }
}
```

## Performance Optimizations

### 1. Pre-Warming

```typescript
// Pre-warm edge locations
class EdgePreWarmer {
  async preWarm() {
    // Load wildcard SSL cert into memory
    await this.loadSSLCerts();

    // Warm DNS cache with common patterns
    await this.warmDNSCache();

    // Pre-compile common configurations
    await this.compileConfigs();

    // Result: First request is as fast as subsequent ones
  }
}
```

### 2. Caching Strategy

```typescript
const cachingStrategy = {
  // Static assets: Cache forever
  static: {
    ttl: 'max',
    staleWhileRevalidate: true
  },

  // DNS records: Cache with short TTL
  dns: {
    ttl: 300, // 5 minutes
    revalidate: 'background'
  },

  // SSL certificates: Cache until expiry
  ssl: {
    ttl: 'until_expiry',
    renewBefore: '30_days'
  },

  // Domain configs: Cache with invalidation
  configs: {
    ttl: 3600, // 1 hour
    invalidateOn: ['update', 'delete']
  }
};
```

### 3. Database Sharding

```typescript
// Shard domains by subdomain prefix
class DomainSharding {
  getShardKey(subdomain: string): string {
    // Use first 2 characters for shard key
    // Distributes load evenly across shards
    return subdomain.substring(0, 2).toLowerCase();
  }

  getShard(subdomain: string): Shard {
    const key = this.getShardKey(subdomain);
    const shardIndex = this.hashFunction(key) % this.shardCount;
    return this.shards[shardIndex];
  }

  // 100 shards = 100× parallelism
  shardCount = 100;
}
```

## Monitoring and Observability

```typescript
class SystemMonitoring {
  async trackMetrics() {
    // Track provisioning latency
    histogram('domain_provision_latency_ms', {
      p50: 450,
      p95: 850,
      p99: 1200,
      max: 3000
    });

    // Track success rate
    counter('domain_provision_success', { rate: 0.999 });

    // Track edge deployment
    gauge('edge_deployment_coverage', { value: 0.99 });

    // Track DNS propagation
    histogram('dns_propagation_seconds', {
      p50: 2.1,
      p95: 4.3,
      p99: 5.8
    });

    // Track SSL provisioning
    counter('ssl_provision_auto', { rate: 1.0 });
  }
}
```

## Failure Modes and Recovery

```typescript
class FailureRecovery {
  async handleFailures() {
    // Edge location failure
    this.on('edge_failure', async (edge) => {
      // Traffic automatically routes to healthy edges
      await this.rerouteTraffic(edge);

      // Alert ops team
      await this.alert({
        severity: 'HIGH',
        message: `Edge ${edge.id} down`,
        impact: `${edge.trafficPercent}% traffic`
      });

      // No user impact (redundancy)
    });

    // Database shard failure
    this.on('shard_failure', async (shard) => {
      // Read from replica
      const replica = await this.getHealthyReplica(shard);

      // Promote replica to primary
      await this.promoteReplica(replica);

      // Rebuild failed shard
      await this.rebuildShard(shard);
    });

    // SSL cert renewal failure
    this.on('ssl_renewal_failure', async (cert) => {
      // Retry with exponential backoff
      await this.retryCertRenewal(cert);

      // Alert if < 7 days to expiry
      if (cert.daysUntilExpiry < 7) {
        await this.alert({
          severity: 'CRITICAL',
          message: 'SSL cert renewal failing'
        });
      }
    });
  }
}
```

## Scalability

```typescript
const scalabilityMetrics = {
  current: {
    domains: 100_000,
    requestsPerSecond: 10_000,
    edgeLocations: 275,
    databaseShards: 100
  },

  capacity: {
    maxDomains: 100_000_000,  // 100M domains
    maxRPS: 1_000_000,        // 1M requests/second
    edgeLocations: 'unlimited',
    autoScaling: true
  },

  limits: {
    provisioningRate: '1000 domains/second',
    parallelRequests: 'unlimited',
    storageCapacity: 'petabytes',
    bandwidth: 'unlimited'
  }
};
```

## Conclusion

Instant domain provisioning requires:

- **Edge network** (275+ global locations)
- **Distributed database** (< 100ms global consensus)
- **Pre-provisioned SSL** (wildcard certs ready)
- **Edge DNS** (no traditional propagation)
- **Parallel deployment** (quorum-based)
- **Aggressive caching** (minimize latency)

Result: Sub-second domain provisioning with global SSL, 3000× faster than traditional.

**Technical excellence, zero configuration:** [builder.domains](https://builder.domains)
